'''
Псевдокод
Данный псевдокод используется для описания алгоритмов.
1. Отступ от левого поля указывает на уровень вложенности.
2. Циклы while, for, repeat и условные конструкции
имеют тот же смысл, что и в pascal-е.
3. Символ “--” обозначает комментарий
4. Символ “:=” обозначает присваивание
5. Переменные локальны в рамках процедуры, если не оговорено иначе
6. Индекс массива пишется в квадратных скобках, конструкция A[i]
означает i элемент в массиве A
7. Возможно использование объектов, состоящих из нескольких полей,
или имеющих несколько атрибутов, значения поля записывается
как ИмяПоля[ИмяОбъекта].
К примеру, длина массива A записывается как Length[A];
что означают квадратные скобки - выясняется по контексту
(переменная, обозначающая массив, или объект является
указателем на составляющие его данные).
После присвоения y:=x для любого поля f будет выполняться
равенство f[y]=f[x]; определение того,
что является атрибутом – функция, переменная или что-либо еще,
- делается по контексту.
8. Указатель может иметь специальное значение NIL,
не указывающее ни на какой объект.
9. Параметры передаются по значению: вызванная процедура
получает собственную копию параметров,
изменения параметров внутри процедуры снаружи не видно.
При передаче объектов копируется указатель на данные,
соответствующие этому объекту.

Задача
Функция сортирующая массив элементов A:
Sort(A,p,r)
1 if p < r
2    then           q := round_half_down((p+r)/2)
3                       Sort(A,p,q)
4                       Sort(A,q+1,r)
5                       Merge(A,p,q,r)

Пример массива:
A = (5,2,4,6,1,3,2,6)

Примера запуска:
Sort(A,1,length[A])

Необходимо:
Разработать алгоритм функции Merge(A,p,q,r) на любом удобном вам языке,
с использованием дополнительной памяти или без нее,
как вам будет быстрее или удобнее в реализации.
Если у вас получится - с радостью ждем вас
для прохождения дополнительного тестирования.
'''

def merge_sort(arr, lf, rg):
    if lf >= rg:
        return
    mid = (lf + rg) // 2
    merge_sort(arr, lf, mid)
    merge_sort(arr, mid + 1, rg)
    merge(arr, lf, mid + 1, rg)


def merge(arr, lf, mid, rg):
    left_sub, right_sub = arr[lf:mid], arr[mid:rg + 1]
    left_sub_id, right_sub_id = 0, 0
    sorted_id = lf

    while left_sub_id < len(left_sub) and right_sub_id < len(right_sub):
        if left_sub[left_sub_id] <= right_sub[right_sub_id]:
            arr[sorted_id] = left_sub[left_sub_id]
            left_sub_id += 1
        else:
            arr[sorted_id] = right_sub[right_sub_id]
            right_sub_id += 1
        sorted_id += 1

    while left_sub_id < len(left_sub):
        arr[sorted_id] = left_sub[left_sub_id]
        left_sub_id += 1
        sorted_id += 1

    while right_sub_id < len(right_sub):
        arr[sorted_id] = right_sub[right_sub_id]
        right_sub_id += 1
        sorted_id += 1
    return arr


a = [5, 2, 4, 6, 1, 3, 2, 6]
merge_sort(a, 1, len(a))
print(a)
# [5, 1, 2, 2, 3, 4, 6, 6]