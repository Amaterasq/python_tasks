'''
Алла ошиблась при копировании из одной
структуры данных в другую. Она хранила массив чисел в кольцевом буфере.
Массив был отсортирован по возрастанию, и в нём
можно было найти элемент за логарифмическое время.
Алла скопировала данные из кольцевого буфера в обычный массив,
но сдвинула данные исходной отсортированной последовательности.
Теперь массив не является отсортированным.
Тем не менее, нужно обеспечить возможность находить в нем элемент за O(logn).
Можно предполагать, что в массиве только уникальные элементы.

От вас требуется реализовать функцию, осуществляющую поиск в
сломанном массиве.
Обратите внимание, что считывать данные и выводить ответ не требуется.

Формат ввода:
Функция принимает массив натуральных чисел и искомое число k.
Длина массива не превосходит 10000. Элементы массива и число k
не превосходят по значению 10000.
В примерах:
В первой строке записано число n –— длина массива.
Во второй строке записано положительное число k –— искомый элемент.
Далее в строку через пробел записано n натуральных чисел – элементы массива.

Формат вывода:
Функция должна вернуть индекс элемента, равного k,
если такой есть в массиве (нумерация с нуля).
Если элемент не найден, функция должна вернуть -1.
Изменять массив нельзя.
Для отсечения неэффективных решений ваша функция будет запускаться от
100000 до 1000000 раз.

Реализован бинарный поиск с дополнительным условием
'''


def broken_search(array, target):
    left, right = 0, len(array) - 1

    while left <= right:
        temp_left = array[left]
        if temp_left == target:
            return left
        temp_right = array[right]
        if temp_right == target:
            return right
        mid = (left + right) // 2
        temp_mid = array[mid]
        if temp_mid == target:
            return mid
        if array[left] < temp_mid:
            if temp_left < target < temp_mid:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if temp_mid < target < temp_right:
                left = mid + 1
            else:
                right = mid - 1
    return -1
